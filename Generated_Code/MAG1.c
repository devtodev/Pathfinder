/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : MAG1.c
**     CDE edition : Standard
**     Project     : Pathfinder
**     Processor   : MKL46Z256VLL4
**     Component   : MAG3110
**     Version     : Component 01.010, Driver 01.00, CPU db: 3.00.000
**     Repository  : My Components
**     Compiler    : GNU C Compiler
**     Date/Time   : 2016-12-23, 01:29, # CodeGen: 78
**     Abstract    :
**         Implements a driver for the MAG3110 Magnetometer from Freescale
**     Settings    :
**          Component Name                                 : MAG1
**          Slave Address                                  : 0E
**          I2C Bus                                        : GI2C1
**          Temperature offset                             : 24
**          INT1 Pin                                       : Enabled
**            INT1                                         : Interrupt
**          Shell                                          : Enabled
**            Shell                                        : CLS1
**            Utility                                      : UTIL1
**     Contents    :
**         Enable                  - byte MAG1_Enable(void);
**         Disable                 - byte MAG1_Disable(void);
**         GetXYZ8                 - uint8_t MAG1_GetXYZ8(signed char *xyz);
**         GetXYZ16                - uint8_t MAG1_GetXYZ16(int16_t *xyz);
**         GetX                    - byte MAG1_GetX(int16_t *value);
**         GetY                    - byte MAG1_GetY(int16_t *value);
**         GetZ                    - byte MAG1_GetZ(int16_t *value);
**         SetFastReadMode         - byte MAG1_SetFastReadMode(bool on);
**         GetFastReadMode         - byte MAG1_GetFastReadMode(bool *isOn);
**         SetTriggerImmediateMode - byte MAG1_SetTriggerImmediateMode(bool on);
**         GetTriggerImmediateMode - byte MAG1_GetTriggerImmediateMode(bool *isOn);
**         SetOversamplingMode     - byte MAG1_SetOversamplingMode(byte bits);
**         GetOversamplingMode     - byte MAG1_GetOversamplingMode(byte *bits);
**         SetDataRateMode         - byte MAG1_SetDataRateMode(byte bits);
**         GetDataRateMode         - byte MAG1_GetDataRateMode(byte *bits);
**         SetRawMode              - byte MAG1_SetRawMode(bool on);
**         GetRawMode              - byte MAG1_GetRawMode(bool *isOn);
**         WhoAmI                  - byte MAG1_WhoAmI(byte *value);
**         GetTemperature          - byte MAG1_GetTemperature(signed char *temperature);
**         GetSysMode              - byte MAG1_GetSysMode(byte *mode);
**         SetSysMode              - byte MAG1_SetSysMode(byte mode);
**         GetUserOffsetCorrection - byte MAG1_GetUserOffsetCorrection(int16_t *x, int16_t *y, int16_t *z);
**         SetUserOffsetCorrection - byte MAG1_SetUserOffsetCorrection(int16_t x, int16_t y, int16_t z);
**         WriteReg                - byte MAG1_WriteReg(byte reg, byte val);
**         ReadReg                 - byte MAG1_ReadReg(byte addr, byte *val);
**         ParseCommand            - byte MAG1_ParseCommand(const unsigned char *cmd, bool *handled, const...
**         MagneticSensorReset     - byte MAG1_MagneticSensorReset(void);
**         Init                    - uint8_t MAG1_Init(void);
**         Deinit                  - uint8_t MAG1_Deinit(void);
**
**     License : Open Source (LGPL)
**     Copyright : (c) Copyright Erich Styger, 2013, all rights reserved.
**     http://www.mcuoneclipse.com
**     This an open source software in the form of a Processor Expert Embedded Component.
**     This is a free software and is opened for education, research and commercial developments under license policy of following terms:
**     * This is a free software and there is NO WARRANTY.
**     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
**     * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/
/*!
** @file MAG1.c
** @version 01.00
** @brief
**         Implements a driver for the MAG3110 Magnetometer from Freescale
*/         
/*!
**  @addtogroup MAG1_module MAG1 module documentation
**  @{
*/         

/* MODULE MAG1. */

#include "MAG1.h"

#define MAG1_CPU_IS_LITTLE_ENDIAN 1 /* Cpu is little endian */

#define MAG1_DIE_TEMP_OFFSET 24 /* offset to temperature reading as value on device is not calibrated */
static uint8_t PrintStatus(const CLS1_StdIOType *io) {
  unsigned char buf[24];
  uint8_t val8;
  int8_t temperature;
  int16_t x, y, z;
  bool isOn;

  CLS1_SendStatusStr((unsigned char*)"MAG1", (unsigned char*)"\r\n", io->stdOut);

  if (MAG1_GetSysMode(&val8)==ERR_OK) {
    if (val8==MAG1_SYSMOD_STANDBY_BIT_MASK) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"STANDBY\r\n");
    } else if (val8==MAG1_SYSMOD_ACTIVE_RAW_BIT_MASK) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ACTIVE, RAW\r\n");
    } else if (val8==MAG1_SYSMOD_ACTIVE_BIT_MASK) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ACTIVE\r\n");
    } else {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"UNKNOWN\r\n");
    }
  } else {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  Sys Mode", buf, io->stdOut);

  CLS1_SendStatusStr((unsigned char*)"  X, Y, Z", (unsigned char*)"", io->stdOut);
  if (MAG1_GetX(&x)!=ERR_OK) {
    CLS1_SendStr((unsigned char*)"FAILED", io->stdOut);
  } else {
    CLS1_SendNum16s(x, io->stdOut);
  }
  CLS1_SendStr((unsigned char*)" ", io->stdOut);
  if (MAG1_GetY(&y)!=ERR_OK) {
    CLS1_SendStr((unsigned char*)"FAILED", io->stdOut);
  } else {
    CLS1_SendNum16s(y, io->stdOut);
  }
  CLS1_SendStr((unsigned char*)" ", io->stdOut);
  if (MAG1_GetZ(&z)!=ERR_OK) {
    CLS1_SendStr((unsigned char*)"FAILED", io->stdOut);
  } else {
    CLS1_SendNum16s(z, io->stdOut);
  }
  CLS1_SendStr((unsigned char*)"\r\n", io->stdOut);

  CLS1_SendStatusStr((unsigned char*)"  Offset", (unsigned char*)"", io->stdOut);
  MAG1_GetUserOffsetCorrection(&x, &y, &z);
  CLS1_SendNum16s(x, io->stdOut);
  CLS1_SendStr((unsigned char*)" ", io->stdOut);
  CLS1_SendNum16s(y, io->stdOut);
  CLS1_SendStr((unsigned char*)" ", io->stdOut);
  CLS1_SendNum16s(z, io->stdOut);
  CLS1_SendStr((unsigned char*)"\r\n", io->stdOut);

  if (MAG1_GetDataRateMode(&val8)!=ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    val8 >>= MAG1_CTRL_REG_1_DR_BITS_POS; /* shift value into position */
    x = MAG1_CTRL_REG_1_DR_START; /* start with base data rate */
    x >>= val8; /* shift base data rate to calculate the set rate */
    UTIL1_Num16sToStr(buf, sizeof(buf), x);
    UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" Hz\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  Data Rate", buf, io->stdOut);

  if (MAG1_GetOversamplingMode(&val8)!=ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    val8 >>= MAG1_CTRL_REG_1_OS_BITS_POS; /* shift value into position */
    x = MAG1_CTRL_REG_1_OS_START; /* start with base data rate */
    x <<= val8; /* shift base data rate to calculate the set rate */
    UTIL1_Num16sToStr(buf, sizeof(buf), x);
    UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"x oversampling\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  Sampling", buf, io->stdOut);

  if (MAG1_GetFastReadMode(&isOn)!=ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    if (isOn) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"on\r\n");
    } else {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"off\r\n");
    }
  }
  CLS1_SendStatusStr((unsigned char*)"  Fast Read", buf, io->stdOut);

  if (MAG1_GetTriggerImmediateMode(&isOn)!=ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    if (isOn) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"immediate on\r\n");
    } else {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"immediate off\r\n");
    }
  }
  CLS1_SendStatusStr((unsigned char*)"  Trigger", buf, io->stdOut);

  if (MAG1_GetRawMode(&isOn)!=ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    if (isOn) {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"on\r\n");
    } else {
      UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"off\r\n");
    }
  }
  CLS1_SendStatusStr((unsigned char*)"  Raw mode", buf, io->stdOut);

  if (MAG1_GetTemperature(&temperature)==ERR_OK) {
    UTIL1_Num8sToStr(buf, sizeof(buf), temperature);
    UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"�C (offset ");
    UTIL1_strcatNum8s(buf, sizeof(buf), MAG1_DIE_TEMP_OFFSET);
    UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"�C)\r\n");
  } else {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  Temperature", buf, io->stdOut);

  if (MAG1_WhoAmI(&val8)==ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"0x");
    UTIL1_strcatNum8Hex(buf, sizeof(buf), val8);
    UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  } else {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  }
  CLS1_SendStatusStr((unsigned char*)"  Who am I", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const CLS1_StdIOType *io) {
  CLS1_SendHelpStr((unsigned char*)"MAG1", (unsigned char*)"Group of MAG1 commands\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  enable|disable", (unsigned char*)"Enables or disables the sensor\r\n", io->stdOut);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetXYZ8 (component MAG3110)
**     Description :
**         Returns in an array the x, y and z sensor values as 8bit
**         values. Note that for this method the FAST_READ flag *shall*
**         be set.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * xyz             - Pointer to an array of three signed 8bit
**                           values which are used to return the
**                           accelerometer values.
**     Returns     :
**         ---             - Error code, ERR_OK for no error.
** ===================================================================
*/
uint8_t MAG1_GetXYZ8(signed char *xyz)
{
  /* NOTE: this function assumes that FAST_READ *is* set, as it reads 3 bytes */
  static const uint8_t addr = MAG1_OUT_X_MSB;

  return GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), (uint8_t*)xyz, 3);
}

/*
** ===================================================================
**     Method      :  MAG1_GetRaw8XYZ (component MAG3110)
**     Description :
**         Returns in an array the x, y and z sensor values as 8bit
**         values.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * xyz             - Pointer to an array of three unsigned 8bit
**                           values which are used to return the
**                           accelerometer values.
**     Returns     :
**         ---             - Error code, ERR_OK for no error.
** ===================================================================
*/
uint8_t MAG1_GetXYZ16(int16_t *xyz)
{
  /* NOTE: this function assumes that FAST_READ is *not* set, as it reads 6 bytes */
  static const uint8_t addr = MAG1_OUT_X_MSB;

  return GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), (uint8_t*)xyz, 6);
}

/*
** ===================================================================
**     Method      :  MAG1_Deinit (component MAG3110)
**     Description :
**         Counterpart to Init() method.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, ERR_OK if everything is ok.
** ===================================================================
*/
uint8_t MAG1_Deinit(void)
{
  return ERR_OK; /* nothing to do */
}

/*
** ===================================================================
**     Method      :  MAG1_Init (component MAG3110)
**     Description :
**         Initializes the device driver
**     Parameters  : None
**     Returns     :
**         ---             - Error code, ERR_OK if everything is ok.
** ===================================================================
*/
uint8_t MAG1_Init(void)
{
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetX (component MAG3110)
**     Description :
**         Returns the X magnetometer value.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * value           - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetX(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = MAG1_OUT_X_MSB;

  if(GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetY (component MAG3110)
**     Description :
**         Returns the Y magnetometer value.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * value           - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetY(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = MAG1_OUT_Y_MSB;

  if (GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetZ (component MAG3110)
**     Description :
**         Returns the Z magnetometer value.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * value           - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetZ(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = MAG1_OUT_Z_MSB;

  if (GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_ParseCommand (component MAG3110)
**     Description :
**         Shell Command Line parser. This method is enabled/disabled
**         depending on if you have the Shell enabled/disabled in the
**         properties.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * handled         - Pointer to variable which tells if
**                           the command has been handled or not
**       * io              - Pointer to I/O structure
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_ParseCommand(const unsigned char *cmd, bool *handled, const CLS1_StdIOType *io)
{
  if (UTIL1_strcmp((char*)cmd, CLS1_CMD_HELP)==0 || UTIL1_strcmp((char*)cmd, "MAG1 help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((UTIL1_strcmp((char*)cmd, CLS1_CMD_STATUS)==0) || (UTIL1_strcmp((char*)cmd, "MAG1 status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (UTIL1_strcmp((char*)cmd, (char*)"MAG1 enable")==0) {
    MAG1_Enable();
    *handled = TRUE;
  } else if (UTIL1_strcmp((char*)cmd, (char*)"MAG1 disable")==0) {
    MAG1_Disable();
    *handled = TRUE;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_SetFastReadMode (component MAG3110)
**     Description :
**         Turns the FR (Fast Read Mode) bit in CTRL_REG_1 on or off
**     Parameters  :
**         NAME            - DESCRIPTION
**         on              - if to turn the FR mode on or off
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetFastReadMode(bool on)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (on) {
    val |= MAG1_CTRL_REG_1_FR_BIT_MASK; /* enable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  } else {
    val &= ~MAG1_CTRL_REG_1_FR_BIT_MASK; /* disable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  }
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetFastReadMode (component MAG3110)
**     Description :
**         Returns the FR (Fast Read Mode) status in the CTRL_REG_1
**         register
**     Parameters  :
**         NAME            - DESCRIPTION
**       * isOn            - Pointer to where to store the status of
**                           the FR bit
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetFastReadMode(bool *isOn)
{
  uint8_t val;

  if(GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *isOn = (bool)(val&MAG1_CTRL_REG_1_FR_BIT_MASK);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_SetTriggerImmediateMode (component MAG3110)
**     Description :
**         Turns the TM (Trigger Immediate Measurement) bit in
**         CTRL_REG_1 on or off
**     Parameters  :
**         NAME            - DESCRIPTION
**         on              - if to turn the TM mode on or off
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetTriggerImmediateMode(bool on)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (on) {
    val |= MAG1_CTRL_REG_1_TM_BIT_MASK; /* enable trigger immediate bit */
  } else {
    val &= ~MAG1_CTRL_REG_1_TM_BIT_MASK; /* disable trigger immediate bit */
  }
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetTriggerImmediateMode (component MAG3110)
**     Description :
**         Returns if TM (Trigger Immediate Mode) in the CTRL_REG_1
**         register is on or off
**     Parameters  :
**         NAME            - DESCRIPTION
**       * isOn            - Pointer to where to store the status
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetTriggerImmediateMode(bool *isOn)
{
  uint8_t val;

  if(GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *isOn = (bool)(val&MAG1_CTRL_REG_1_TM_BIT_MASK);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_SetRawMode (component MAG3110)
**     Description :
**         Turns the RAW (Raw or data output correction) bit in
**         CTRL_REG_2 on or off
**     Parameters  :
**         NAME            - DESCRIPTION
**         on              - if to turn the RAW mode on or off
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetRawMode(bool on)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_2, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (on) {
    val |= MAG1_CTRL_REG_2_RAW_BIT_MASK; /* enable RAW mode */
  } else {
    val &= ~MAG1_CTRL_REG_2_RAW_BIT_MASK; /* disable RAW mode */
  }
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_2, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetRawMode (component MAG3110)
**     Description :
**         Returns the RAW (raw or data output correction) status in
**         the CTRL_REG_2 register
**     Parameters  :
**         NAME            - DESCRIPTION
**       * isOn            - Pointer to where to store the status of
**                           the RAW bit
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetRawMode(bool *isOn)
{
  uint8_t val;

  if(GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_2, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *isOn = (bool)(val&MAG1_CTRL_REG_2_RAW_BIT_MASK);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_SetOversamplingMode (component MAG3110)
**     Description :
**         Sets the OS (oversampling selection) bits in the CTRL_REG_1
**         register.
**     Parameters  :
**         NAME            - DESCRIPTION
**         bits            - Oversampling mode, one of
**                           CTRL_REG_1_OS_xxxHZ_BIT_MASK
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetOversamplingMode(byte bits)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  val |= (uint8_t)(bits & MAG1_CTRL_REG_1_OS_FULL_BIT_MASK); /* making sure we use the right bits */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetOversamplingMode (component MAG3110)
**     Description :
**         Returns the OS (oversampling selection) bits in the
**         CTRL_REG_1 register.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * bits            - Pointer to where to store the
**                           oversampling mode bits, one of
**                           CTRL_REG_1_OS_xxxHZ_BIT_MASK
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetOversamplingMode(byte *bits)
{
  uint8_t val;

  if(GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *bits = (uint8_t)(val & MAG1_CTRL_REG_1_OS_FULL_BIT_MASK); /* making sure we use the right bits */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_SetDataRateMode (component MAG3110)
**     Description :
**         Sets the DR (data rate) bits in the CTRL_REG_1 register.
**     Parameters  :
**         NAME            - DESCRIPTION
**         bits            - Oversampling mode, one of
**                           CTRL_REG_1_DR_xxxHZ_BIT_MASK
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetDataRateMode(byte bits)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  val |= (uint8_t)(bits & MAG1_CTRL_REG_1_DR_FULL_BIT_MASK); /* making sure we use the right bits */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetDataRateMode (component MAG3110)
**     Description :
**         Returns the DR (data rate) bits in the CTRL_REG_1 register.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * bits            - Pointer to where to store the
**                           oversampling mode bits, one of
**                           CTRL_REG_1_DR_xxxHZ_BIT_MASK
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetDataRateMode(byte *bits)
{
  uint8_t val;

  if(GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *bits = (uint8_t)(val & MAG1_CTRL_REG_1_DR_FULL_BIT_MASK); /* making sure we use the right bits */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_Enable (component MAG3110)
**     Description :
**         Enables the device with setting the ACTIVE bit in the CTRL
**         register 1
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_Enable(void)
{
  uint8_t val, res;

  res = GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val);
  if (res!=ERR_OK) {
    return res;
  }
  val |= MAG1_CTRL_REG_1_AC_BIT_MASK; /* enable device */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_Disable (component MAG3110)
**     Description :
**         Disables the device with clearing the ACTIVE bit in the CTRL
**         register 1
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_Disable(void)
{
  uint8_t val, res;

  res = GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val);
  if (res!=ERR_OK) {
    return res;
  }
  val &= ~MAG1_CTRL_REG_1_AC_BIT_MASK; /* disable device */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetTemperature (component MAG3110)
**     Description :
**         Returns the temperature of the die as signed 8bit values in
**         degree Celsius
**     Parameters  :
**         NAME            - DESCRIPTION
**       * temperature     - Pointer to variable where
**                           to store the temperature
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetTemperature(signed char *temperature)
{
  int8_t temp;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_DIE_TEMP, (uint8_t*)&temp) != ERR_OK) {
    return ERR_FAILED;
  }
  *temperature = (int8_t)(temp+MAG1_DIE_TEMP_OFFSET);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_WhoAmI (component MAG3110)
**     Description :
**         Returns the value of the WHO_AM_I (0x07) register
**     Parameters  :
**         NAME            - DESCRIPTION
**       * value           - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_WhoAmI(byte *value)
{
  return GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_WHO_AM_I, value);
}

/*
** ===================================================================
**     Method      :  MAG1_GetSysMode (component MAG3110)
**     Description :
**         Returns the SYSMOD (0x08) status
**     Parameters  :
**         NAME            - DESCRIPTION
**       * mode            - Pointer to where to store the value.
**                           Returns 0x00 (STANDBY), 0x01 (ACTIVE, raw
**                           data) or 0x02 (ACTIVE, non-RAW data)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetSysMode(byte *mode)
{
  return GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_SYSMOD, mode);
}

/*
** ===================================================================
**     Method      :  MAG1_SetSysMode (component MAG3110)
**     Description :
**         Sets the SYSMOD (0x08) status register
**     Parameters  :
**         NAME            - DESCRIPTION
**         mode            - Set the system mode. 0x00
**                           (SYSMOD_STANDBY_BIT_MASK), 0x01
**                           (SYSMOD_ACTIVE_RAW_BIT_MASK) or 0x02
**                           (SYSMOD_ACTIVE_BIT_MASK)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetSysMode(byte mode)
{
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_SYSMOD, mode);
}

/*
** ===================================================================
**     Method      :  MAG1_Read16bitBEValue (component MAG3110)
**
**     Description :
**         Reads a 16bit value to the device. Value is read in Big Endian 
**         and returned in the proper format depending of LE/BE of 
**         microcontroller.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte MAG1_Read16bitBEValue(byte addr, word *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    uint16_t be;
  } val;
  uint8_t res;

  res = GI2C1_ReadAddress(MAG1_I2C_ADDR, &addr, sizeof(addr), &val.buf[0], sizeof(val.buf));
  if(res!=ERR_OK) {
    return res; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (uint16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_Write16bitBEValue (component MAG3110)
**
**     Description :
**         Writes a 16bit value to the device. Value is written in Big 
**         Endian.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte MAG1_Write16bitBEValue(byte addr, word value)
{
  union {
    uint8_t buf[2]; /* value on device is in big endian */
    uint16_t be;
  } val;

#if MAG1_CPU_IS_LITTLE_ENDIAN
  val.buf[0] = (uint8_t)(value);
  val.buf[1] = (uint8_t)(value>>8);
#else
  val.be = val; /* already in BE */
#endif
  return GI2C1_WriteAddress(MAG1_I2C_ADDR, &addr, sizeof(addr), &val.buf[0], sizeof(val.buf));
}

/*
** ===================================================================
**     Method      :  MAG1_GetUserOffsetCorrection (component MAG3110)
**     Description :
**         Returns the user offset correction values from the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * x               - Pointer to where to store the x offset
**       * y               - Pointer to where to store the y offset
**       * z               - Pointer to where to store the z offset
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetUserOffsetCorrection(int16_t *x, int16_t *y, int16_t *z)
{
  uint8_t res;

  res = MAG1_Read16bitBEValue(MAG1_OFF_X_MSB, (uint16_t*)x);
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = MAG1_Read16bitBEValue(MAG1_OFF_Y_MSB, (uint16_t*)y);
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = MAG1_Read16bitBEValue(MAG1_OFF_Z_MSB, (uint16_t*)z);
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_SetUserOffsetCorrection (component MAG3110)
**     Description :
**         Sets the user offset correction values
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x offset
**         y               - y offset
**         z               - z offset
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetUserOffsetCorrection(int16_t x, int16_t y, int16_t z)
{
  uint8_t res;

  res = MAG1_Write16bitBEValue(MAG1_OFF_X_MSB, (uint16_t)(x<<1)); /* bit 0 is always zero */
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = MAG1_Write16bitBEValue(MAG1_OFF_Y_MSB, (uint16_t)(y<<1)); /* bit 0 is always zero */
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = MAG1_Write16bitBEValue(MAG1_OFF_Z_MSB, (uint16_t)(z<<1)); /* bit 0 is always zero */
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_WriteReg (component MAG3110)
**     Description :
**         Writes to a device register address
**     Parameters  :
**         NAME            - DESCRIPTION
**         reg             - register address
**         val             - Value to write
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_WriteReg(byte reg, byte val)
{
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_SYSMOD, val);
}

/*
** ===================================================================
**     Method      :  MAG1_ReadReg (component MAG3110)
**     Description :
**         Reads from a device register address
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - Device register address
**       * val             - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_ReadReg(byte addr, byte *val)
{
  return GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, addr, val);
}

/*
** ===================================================================
**     Method      :  MAG1_MagneticSensorReset (component MAG3110)
**     Description :
**         Initiates a magnetic sensor reset cycle that will restore
**         correct operation after exposure to an excessive magnetic
**         field which exceeds the Full Scale Range but is less than
**         the Maximum Applied Magnetic Field.
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_MagneticSensorReset(void)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_2, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  val |= MAG1_CTRL_REG_2_MAG_RST_BIT_MASK; /* set one shot reset bit */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_2, val);
}

/* END MAG1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
